{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An ORM / OGM for the Apache TinkerPop\u2122 graph stack. Licensed under the Apache Software License v2 The Ferma project was originally created as an alternative to the TinkerPop2 Frames project. Which at the time lacked features needed by the community, and its performance was cripplingly slow. Today Ferma is a robust framework that takes on a role similar to an Object-relational Model (ORM) library for traditional databases. Ferma is often referred to as a Object-graph Model (OGM) library, and maps Java objects to elements in a graph such as a Vertex or an Edges. In short it allows a schema to be defined using java interfaces and classes which provides a level of abstraction for interacting with the underlying graph. Ferma 3.x Supports TinkerPop3 . For tinkerPop2 support use Ferma version 2.x. Annotated classes in Ferma have their abstract methods implemented using code generation during start-up with Byte Buddy, avoiding the need for proxy classes. This in turn significantly improves performance when compared with TinkerPop Frames and other frameworks. Ferma offers many features including several annotation types to reduce the need for boilerplate code as well as handling Java typing transparently. This ensures whatever the type of the object is when you persist it to the graph the same Java type will be used when instantiating a class off of the graph. Ferma is designed to easily replace TinkerPop Frames in existing code, as such, the annotations provided by Ferma are a super-set of those provided by TinkerPop Frames. Ferma is built directly on top of TinkerPop and allows access to all of the internals. This ensures all the TinkerPop features are available to the end-user. The TinkerPop stack provides several tools which can be used to work with the Ferma engine. Gremlin , a database agnostic query language for Graph Databases. Gremlin Server , a server that provides an interface for executing Gremlin on remote machines. a data-flow framework for splitting, merging, filtering, and transforming of data Graph Computer , a framework for running algorithms against a Graph Database. Support for both OLTP and OLAP engines. TinkerGraph a Graph Database and the reference implementation for TinkerPop. Native Gephi integration for visualizing graphs. Interfaces for most major Graph Compute Engines including Hadoop M/R . Spark , and Giraph . Ferma also supports any of the many databases compatible with TinkerPop including the following. Titan Neo4j OrientDB MongoDB Oracle NoSQL TinkerGraph Ferma Javadocs: latest - 3.3.1 - 3.3.0 - 3.2.1 - 3.2.0 - 3.1.0 - 3.0.3 - 3.0.2 - 3.0.1 - 3.0.0 - 2.4.0 - 2.3.0 - 2.2.2 - 2.2.1 - 2.2.0 - 2.1.0 - 2.0.6 - 2.0.5 - 2.0.4 - 2.0.3 - 2.0.2 - 2.0.1 - 2.0.0 For support please use Gitter or the official Ferma mailing list and Discourse forum . Please file bugs and feature requests on QOTO GitLab a reference to some older issues can be found at Github . Obtaining the Source \u00b6 The official source repository for Ferma is located in the Syncleus Github repository and can be cloned using the following command. git clone https://git.qoto.org/Ferma/Ferma.git","title":"Home"},{"location":"#obtaining-the-source","text":"The official source repository for Ferma is located in the Syncleus Github repository and can be cloned using the following command. git clone https://git.qoto.org/Ferma/Ferma.git","title":"Obtaining the Source"},{"location":"comparing_the_alternatives/","text":"There are several OGM/ORM options out there. For the purposes of this document we will focus only on those that have a stable release, or are close to a stable release. At the time of this writing those are: Tinkerpop Framed and Totorom. Benchmarks \u00b6 We maintain an informal project for benchmarking Ferma against other OGM available, you can find the source here . However below is a matrix breakdown of the results. Instead of showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it means the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if it indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out performed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes. Tinkerpop 2 Blueprints Gremlin Pipeline Tinkerpop3 Frames Totorom Peapod Get adjacencies via annotation Not capable Not capable Not capable x2.09 Not capable x2.65 Get verticies (untyped) x0.89 x3.94 x16.98 Not capable x4.24 Not capable Get verticies (typed) x0.92 x3.94 Not capable x0.96 x4.20 x20.74 Get verticies and call next (untyped) x0.79 x3.87 x11.74 Not capable x4.81 Not capable Get verticies and call next (typed) x0.72 x2.91 Not capable x1.94 x3.31 x16.70 Note These bencharks were performed comparing our v2.x branch. These benchmarks need to be updated to reflect changes in Tinkerpop3 as well as the Ferma v3.x branch. As can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While results do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the benchmark program and run it for yourself! Feature Breakdown \u00b6 Ferma also supports all the features provided by the alternatives out there, not to mention several novel features. The following gives a quick breakdown of the features of the various frameworks. We also link to some Ferma examples showing the various features in action. Feature Ferma Frames Totorom Peapod JPA-like Annotations Supported Supported Not Supported Supported Type information encoded into graph Supported Supported Supported Supported Framing of elements instantiated according to type hierarchy Supported Supported Supported Supported Element queried by type hierarchy Supported Not Supported Not Supported Partial * Turning off type resolution on a per call basis Supported Not Supported Not Supported Not Supported Changing the encoded graph type already stored in the database Supported Not Supported Not Supported Not Supported Customizing the way type information is stored in the graph Supported Not Supported Not Supported Not Supported Tinkerpop 2 support Supported Supported Supported Not Supported Tinkerpop 3 support Supported Not Supported Not Supported Supported * While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to query for a specific type while excluding subtypes.","title":"Comparing the Alternatives"},{"location":"comparing_the_alternatives/#benchmarks","text":"We maintain an informal project for benchmarking Ferma against other OGM available, you can find the source here . However below is a matrix breakdown of the results. Instead of showing raw execution time we show the ratio of each OGM compared to Ferma. Therefore if the table lists 1x then it means the framework has the same execution time as Ferma, if it lists 2x then it took twice as long to execute, and if it indicates 0.5x then it took half the time to execute. Obviously any value less than 1x indicates the OGM out performed Ferma and any value greater than 1x indicates Ferma had the superior performance tiimes. Tinkerpop 2 Blueprints Gremlin Pipeline Tinkerpop3 Frames Totorom Peapod Get adjacencies via annotation Not capable Not capable Not capable x2.09 Not capable x2.65 Get verticies (untyped) x0.89 x3.94 x16.98 Not capable x4.24 Not capable Get verticies (typed) x0.92 x3.94 Not capable x0.96 x4.20 x20.74 Get verticies and call next (untyped) x0.79 x3.87 x11.74 Not capable x4.81 Not capable Get verticies and call next (typed) x0.72 x2.91 Not capable x1.94 x3.31 x16.70 Note These bencharks were performed comparing our v2.x branch. These benchmarks need to be updated to reflect changes in Tinkerpop3 as well as the Ferma v3.x branch. As can be seen Ferma out performs all the alternative solutions considerably by several orders of magnitude. While results do vary slightly from system to system these results are pretty close to typical. Go ahead, check out the benchmark program and run it for yourself!","title":"Benchmarks"},{"location":"comparing_the_alternatives/#feature-breakdown","text":"Ferma also supports all the features provided by the alternatives out there, not to mention several novel features. The following gives a quick breakdown of the features of the various frameworks. We also link to some Ferma examples showing the various features in action. Feature Ferma Frames Totorom Peapod JPA-like Annotations Supported Supported Not Supported Supported Type information encoded into graph Supported Supported Supported Supported Framing of elements instantiated according to type hierarchy Supported Supported Supported Supported Element queried by type hierarchy Supported Not Supported Not Supported Partial * Turning off type resolution on a per call basis Supported Not Supported Not Supported Not Supported Changing the encoded graph type already stored in the database Supported Not Supported Not Supported Not Supported Customizing the way type information is stored in the graph Supported Not Supported Not Supported Not Supported Tinkerpop 2 support Supported Supported Supported Not Supported Tinkerpop 3 support Supported Not Supported Not Supported Supported * While Peapod does support querying for all instances of a type, and its subtypes, it does not support a mechanism to query for a specific type while excluding subtypes.","title":"Feature Breakdown"},{"location":"features/","text":"The following gives a quick breakdown of some of the features of the Ferma framework along with examples. JPA-like Annotations Type information encoded into graph Framing of elements instantiated according to type hierarchy Element queried by type hierarchy Turning off type resolution on a per call basis Changing the encoded graph type already stored in the database Customizing the way type information is stored in the graph Tinkerpop 2 support Tinkerpop 3 support JPA-like Annotations \u00b6 public abstract class Person extends AbstractVertexFrame { @Property ( \"name\" ) public abstract String getName (); @Property ( \"name\" ) public abstract void setName ( String name ); @Adjacency ( label = \"knows\" ) public abstract List < Person > getKnowsPeople (); } public abstract class Programmer extends Person { } public void testAnnotatedTyping () { Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class , Knows . class })); Graph graph = TinkerGraph . open (); //implies annotated mode FramedGraph fg = new DelegatingFramedGraph ( graph , true , types ); Person jeff = fg . addFramedVertex ( Programmer . class ); jeff . setName ( \"Jeff\" ); Person julia = fg . addFramedVertex ( Person . class ); julia . setName ( \"Julia\" ); julia . addKnows ( jeff ); Person juliaAgain = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Julia\" )). next ( Person . class ); Person jeffAgain = juliaAgain . getKnowsPeople (). get ( 0 ); assert jeffAgain instanceof Programmer ; assert jeffAgain . getName (). equals ( \"Jeff\" ); } Type information encoded into graph \u00b6 Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class })); Graph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Person . class ); Person person = fg . traverse ( g -> g . V ()). next ( Program . class ); String personClassName = Person . class . getName (); String encodedClassName = person . getProperty ( PolymorphicTypeResolver . TYPE_RESOLUTION_KEY ) assert personClassName . equals ( encodedClassName ); Framing instantiated by type hierarchy \u00b6 Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); //make sure the newly added node is actually a programmer Person programmer = fg . traverse ( g -> g . V ()). next ( Person . class ); assert programmer instanceof Programmer ; Element queried by type hierarchy \u00b6 Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); fg . addFramedVertex ( Person . class ); //counts how many people (or subclasses thereof) in the graph. assert fg . traverse ( g -> g . getTypeResolver (). hasType ( g . V (), Person . class )). toList ( Person . class ). size () == 2 ; //counts how many programmers are in the graph assert fg . traverse ( g -> g . getTypeResolver (). hasType ( g . V (), Programmer . class )). toList ( Person . class ). size () == 1 ; Turning off type resolution per call \u00b6 Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); //With type resolution is active it should be a programmer assert fg . traverse ( g -> g . V ()). next ( Person . class ) instanceof Programmer ; //With type resolution bypassed it is no longer a programmer assert ! ( fg . traverse ( g -> g . V ()). nextExplicit ( Person . class ) instanceof Programmer ); Changing type encoded in the graph \u00b6 Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); //make sure the newly added node is actually a programmer Person programmer = fg . traverse ( g -> g . V ()). next ( Person . class ); assert programmer instanceof Programmer ; //change the type resolution to person programmer . setTypeResolution ( Person . class ); //make sure the newly added node is actually a programmer Person person = fg . traverse ( g -> g . V ()). next ( Person . class ); assert ! ( person instanceof Programmer ); Customizing how types are encoded \u00b6 Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class })); final ReflectionCache cache = new ReflectionCache ( types ); FrameFactory factory = new AnnotationFrameFactory ( cache ); TypeResolver resolver = new PolymorphicTypeResolver ( cache , \"customTypeKey\" ); Graph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , factory , resolver ); fg . addFramedVertex ( Person . class ); Person person = fg . traverse ( g -> g . V ()). next ( Programmer . class ); String personClassName = Person . class . getName (); String encodedClassName = person . getProperty ( \"customTypeKey\" ) assert personClassName . equals ( encodedClassName );","title":"Features"},{"location":"features/#jpa-like-annotations","text":"public abstract class Person extends AbstractVertexFrame { @Property ( \"name\" ) public abstract String getName (); @Property ( \"name\" ) public abstract void setName ( String name ); @Adjacency ( label = \"knows\" ) public abstract List < Person > getKnowsPeople (); } public abstract class Programmer extends Person { } public void testAnnotatedTyping () { Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class , Knows . class })); Graph graph = TinkerGraph . open (); //implies annotated mode FramedGraph fg = new DelegatingFramedGraph ( graph , true , types ); Person jeff = fg . addFramedVertex ( Programmer . class ); jeff . setName ( \"Jeff\" ); Person julia = fg . addFramedVertex ( Person . class ); julia . setName ( \"Julia\" ); julia . addKnows ( jeff ); Person juliaAgain = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Julia\" )). next ( Person . class ); Person jeffAgain = juliaAgain . getKnowsPeople (). get ( 0 ); assert jeffAgain instanceof Programmer ; assert jeffAgain . getName (). equals ( \"Jeff\" ); }","title":"JPA-like Annotations"},{"location":"features/#type-information-encoded-into-graph","text":"Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class })); Graph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Person . class ); Person person = fg . traverse ( g -> g . V ()). next ( Program . class ); String personClassName = Person . class . getName (); String encodedClassName = person . getProperty ( PolymorphicTypeResolver . TYPE_RESOLUTION_KEY ) assert personClassName . equals ( encodedClassName );","title":"Type information encoded into graph"},{"location":"features/#framing-instantiated-by-type-hierarchy","text":"Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); //make sure the newly added node is actually a programmer Person programmer = fg . traverse ( g -> g . V ()). next ( Person . class ); assert programmer instanceof Programmer ;","title":"Framing instantiated by type hierarchy"},{"location":"features/#element-queried-by-type-hierarchy","text":"Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); fg . addFramedVertex ( Person . class ); //counts how many people (or subclasses thereof) in the graph. assert fg . traverse ( g -> g . getTypeResolver (). hasType ( g . V (), Person . class )). toList ( Person . class ). size () == 2 ; //counts how many programmers are in the graph assert fg . traverse ( g -> g . getTypeResolver (). hasType ( g . V (), Programmer . class )). toList ( Person . class ). size () == 1 ;","title":"Element queried by type hierarchy"},{"location":"features/#turning-off-type-resolution-per-call","text":"Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); //With type resolution is active it should be a programmer assert fg . traverse ( g -> g . V ()). next ( Person . class ) instanceof Programmer ; //With type resolution bypassed it is no longer a programmer assert ! ( fg . traverse ( g -> g . V ()). nextExplicit ( Person . class ) instanceof Programmer );","title":"Turning off type resolution per call"},{"location":"features/#changing-type-encoded-in-the-graph","text":"Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class })); TinkerGraph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , types ); fg . addFramedVertex ( Programmer . class ); //make sure the newly added node is actually a programmer Person programmer = fg . traverse ( g -> g . V ()). next ( Person . class ); assert programmer instanceof Programmer ; //change the type resolution to person programmer . setTypeResolution ( Person . class ); //make sure the newly added node is actually a programmer Person person = fg . traverse ( g -> g . V ()). next ( Person . class ); assert ! ( person instanceof Programmer );","title":"Changing type encoded in the graph"},{"location":"features/#customizing-how-types-are-encoded","text":"Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class })); final ReflectionCache cache = new ReflectionCache ( types ); FrameFactory factory = new AnnotationFrameFactory ( cache ); TypeResolver resolver = new PolymorphicTypeResolver ( cache , \"customTypeKey\" ); Graph g = new TinkerGraph (); FramedGraph fg = new DelegatingFramedGraph ( g , factory , resolver ); fg . addFramedVertex ( Person . class ); Person person = fg . traverse ( g -> g . V ()). next ( Programmer . class ); String personClassName = Person . class . getName (); String encodedClassName = person . getProperty ( \"customTypeKey\" ) assert personClassName . equals ( encodedClassName );","title":"Customizing how types are encoded"},{"location":"getting_started/","text":"Ferma provides three levels of type resolution: untyped, simple, and annotated. In untyped mode Ferma doesn't handle typing at all, instead the type must be explicitly indicated whenever querying. In simple mode Ferma provides type context encoded as graph element properties which ensures the same type comes out that goes in to a graph. In annotated mode all the features of simple mode are provided as well as enabling the use of annotations on abstract methods to instruct Ferma to dynamically construct byte code to implement the abstract methods at start up. Dependency \u00b6 To include Ferma in your project of choice include the following Maven dependency into your build. <dependency> <groupId> com.syncleus.ferma </groupId> <artifactId> ferma </artifactId> <version> 3.3.1 </version> </dependency> Untyped Mode Example \u00b6 In untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be instantiated when performing queries. Lets start with a simple example domain. public class Person extends AbstractVertexFrame { public String getName () { return getProperty ( \"name\" ); } public void setName ( String name ) { setProperty ( \"name\" , name ); } public List <? extends Knows > getKnowsList () { return traverse (( v ) -> v . outE ( \"knows\" )). toList ( Knows . class ); } public Knows addKnows ( Person friend ) { return addFramedEdge ( \"knows\" , friend , Knows . class ); } } public class Knows extends AbstractEdgeFrame { public void setYears ( int years ) { setProperty ( \"years\" , years ); } public int getYears () { return getProperty ( \"years\" ); } } And here is how you interact with the framed elements: public void testUntyped () { Graph graph = TinkerGraph . open (); // implies untyped mode FramedGraph fg = new DelegatingFramedGraph ( graph ); Person p1 = fg . addFramedVertex ( Person . class ); p1 . setName ( \"Jeff\" ); Person p2 = fg . addFramedVertex ( Person . class ); p2 . setName ( \"Julia\" ); Knows knows = p1 . addKnows ( p2 ); knows . setYears ( 15 ); Person jeff = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Jeff\" )). next ( Person . class ); Assert . assertEquals ( \"Jeff\" , jeff . getName ()); } Simple Mode Example \u00b6 In simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend from a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to provide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when reading from the graph. Say we extend the Person class with the Programmer class. public class Programmer extends Person { } Using simple mode will save the type of Java class the element was created with for use later: public void testSimpleTyping () { Graph graph = TinkerGraph . open (); // implies simple mode FramedGraph fg = new DelegatingFramedGraph ( graph , true , false ); Person p1 = fg . addFramedVertex ( Programmer . class ); p1 . setName ( \"Jeff\" ); Person p2 = fg . addFramedVertex ( Person . class ); p2 . setName ( \"Julia\" ); Person jeff = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Jeff\" )). next ( Person . class ); Person julia = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Julia\" )). next ( Person . class ); Assert . assertEquals ( Programmer . class , jeff . getClass ()); Assert . assertEquals ( Person . class , julia . getClass ()); } Annotated Mode Example \u00b6 In annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and concrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction. Annotated mode also provides a set of annotations which must be used to define any abstract methods that are to be implemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more power to determine parent-child relationships at run time. The same example as above done with annotations would look something like this. public abstract class Person extends AbstractVertexFrame { @Property ( \"name\" ) public abstract String getName (); @Property ( \"name\" ) public abstract void setName ( String name ); @Adjacency ( label = \"knows\" ) public abstract List < Person > getKnowsPeople (); @Incidence ( label = \"knows\" ) public abstract List < Knows > getKnows (); @Incidence ( label = \"knows\" ) public abstract Knows addKnows ( Person friend ); public List <? extends Person > getFriendsNamedBill () { return this . traverse ( input -> input . out ( \"knows\" ). has ( \"name\" , \"bill\" )). toList ( Person . class ); } } public abstract class Knows extends AbstractEdgeFrame { @Property ( \"years\" ) public abstract void setYears ( int years ); @Property ( \"years\" ) public abstract int getYears (); @InVertex public abstract Person getIn (); @OutVertex public abstract Person getOut (); } public abstract class Programmer extends Person { } If we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used. In this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and construct the byte code for any abstract annotated methods. public void testAnnotatedTyping () { Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class , Knows . class })); Graph graph = TinkerGraph . open (); //implies annotated mode FramedGraph fg = new DelegatingFramedGraph ( graph , true , types ); Person jeff = fg . addFramedVertex ( Programmer . class ); jeff . setName ( \"Jeff\" ); Person julia = fg . addFramedVertex ( Person . class ); julia . setName ( \"Julia\" ); julia . addKnows ( jeff ); Person juliaAgain = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Julia\" )). next ( Person . class ); Person jeffAgain = juliaAgain . getKnowsPeople (). get ( 0 ); Assert . assertTrue ( Programmer . class . isAssignableFrom ( jeffAgain . getClass ())); Assert . assertTrue ( Person . class . isAssignableFrom ( juliaAgain . getClass ())); }","title":"Getting Started"},{"location":"getting_started/#dependency","text":"To include Ferma in your project of choice include the following Maven dependency into your build. <dependency> <groupId> com.syncleus.ferma </groupId> <artifactId> ferma </artifactId> <version> 3.3.1 </version> </dependency>","title":"Dependency"},{"location":"getting_started/#untyped-mode-example","text":"In untyped mode there is no automatic typing. Whatever class is explicitly indicated is the type that will be instantiated when performing queries. Lets start with a simple example domain. public class Person extends AbstractVertexFrame { public String getName () { return getProperty ( \"name\" ); } public void setName ( String name ) { setProperty ( \"name\" , name ); } public List <? extends Knows > getKnowsList () { return traverse (( v ) -> v . outE ( \"knows\" )). toList ( Knows . class ); } public Knows addKnows ( Person friend ) { return addFramedEdge ( \"knows\" , friend , Knows . class ); } } public class Knows extends AbstractEdgeFrame { public void setYears ( int years ) { setProperty ( \"years\" , years ); } public int getYears () { return getProperty ( \"years\" ); } } And here is how you interact with the framed elements: public void testUntyped () { Graph graph = TinkerGraph . open (); // implies untyped mode FramedGraph fg = new DelegatingFramedGraph ( graph ); Person p1 = fg . addFramedVertex ( Person . class ); p1 . setName ( \"Jeff\" ); Person p2 = fg . addFramedVertex ( Person . class ); p2 . setName ( \"Julia\" ); Knows knows = p1 . addKnows ( p2 ); knows . setYears ( 15 ); Person jeff = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Jeff\" )). next ( Person . class ); Assert . assertEquals ( \"Jeff\" , jeff . getName ()); }","title":"Untyped Mode Example"},{"location":"getting_started/#simple-mode-example","text":"In simple mode you must provide concrete classes, no abstract or interfaces allowed, and the class should always extend from a FramedVertex or FramedEdge. Simple mode doesn't provide any annotations either. The purpose of simple mode is to provide type resolution. Basically the type of object you use when adding to the graph is the same type you get out when reading from the graph. Say we extend the Person class with the Programmer class. public class Programmer extends Person { } Using simple mode will save the type of Java class the element was created with for use later: public void testSimpleTyping () { Graph graph = TinkerGraph . open (); // implies simple mode FramedGraph fg = new DelegatingFramedGraph ( graph , true , false ); Person p1 = fg . addFramedVertex ( Programmer . class ); p1 . setName ( \"Jeff\" ); Person p2 = fg . addFramedVertex ( Person . class ); p2 . setName ( \"Julia\" ); Person jeff = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Jeff\" )). next ( Person . class ); Person julia = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Julia\" )). next ( Person . class ); Assert . assertEquals ( Programmer . class , jeff . getClass ()); Assert . assertEquals ( Person . class , julia . getClass ()); }","title":"Simple Mode Example"},{"location":"getting_started/#annotated-mode-example","text":"In annotated mode you can either provide concrete classes, abstract classes, or even interfaces. Abstract classes and concrete classes must extend from FramedVertex or FramedEdge, however, interfaces do not have this restriction. Annotated mode also provides a set of annotations which must be used to define any abstract methods that are to be implemented by the engine. Annotated mode provides the same type resolution as provided by simple mode with a bit more power to determine parent-child relationships at run time. The same example as above done with annotations would look something like this. public abstract class Person extends AbstractVertexFrame { @Property ( \"name\" ) public abstract String getName (); @Property ( \"name\" ) public abstract void setName ( String name ); @Adjacency ( label = \"knows\" ) public abstract List < Person > getKnowsPeople (); @Incidence ( label = \"knows\" ) public abstract List < Knows > getKnows (); @Incidence ( label = \"knows\" ) public abstract Knows addKnows ( Person friend ); public List <? extends Person > getFriendsNamedBill () { return this . traverse ( input -> input . out ( \"knows\" ). has ( \"name\" , \"bill\" )). toList ( Person . class ); } } public abstract class Knows extends AbstractEdgeFrame { @Property ( \"years\" ) public abstract void setYears ( int years ); @Property ( \"years\" ) public abstract int getYears (); @InVertex public abstract Person getIn (); @OutVertex public abstract Person getOut (); } public abstract class Programmer extends Person { } If we pass a collection of Class objects to the FramedGraph constructor then the annotated type resolver will be used. In this mode you want to tell the engine what classes you will be using so it can handle type resolution properly and construct the byte code for any abstract annotated methods. public void testAnnotatedTyping () { Set < Class <?>> types = new HashSet < Class <?>> ( Arrays . asList ( new Class <?>[] { Person . class , Programmer . class , Knows . class })); Graph graph = TinkerGraph . open (); //implies annotated mode FramedGraph fg = new DelegatingFramedGraph ( graph , true , types ); Person jeff = fg . addFramedVertex ( Programmer . class ); jeff . setName ( \"Jeff\" ); Person julia = fg . addFramedVertex ( Person . class ); julia . setName ( \"Julia\" ); julia . addKnows ( jeff ); Person juliaAgain = fg . traverse (( g ) -> g . V (). has ( \"name\" , \"Julia\" )). next ( Person . class ); Person jeffAgain = juliaAgain . getKnowsPeople (). get ( 0 ); Assert . assertTrue ( Programmer . class . isAssignableFrom ( jeffAgain . getClass ())); Assert . assertTrue ( Person . class . isAssignableFrom ( juliaAgain . getClass ())); }","title":"Annotated Mode Example"},{"location":"glossary/","text":"Frame - A class from the schema that represents an element from the graph. A frame usually extends either a VertexFrame or an EdgeFrame, though they are not required to do so. Element - Either a vertex or an edge in a graph.","title":"Glossary"},{"location":"object_mapping/","text":"Ferma is an Object-graph Model (OGM). An Object-graph Model is to a Graph Database as an Object-relational Model (ORM) is to a Relational Database. That is to say that it maps Java Objects to edges and vertex in a graph database. As a natural consequence the Java types become an implied Schema for a Graph Database even if the underlying implementation doesnt support the notion of a schema. The objects associated with the various types of Edges and Vertex in a graph are collectively called the Graph Data Model (GDM). Each Java type in the GDM will usually represent a class of Edges or Vertex in the underlying graph. All Edges in the model will extend from the EdgeFrame interface and all vertex will extend from the VertexFrame interface. The individual classes that comprise the GDM are usually simply refered to as frames. The methods defined by a frame will represent interactions with the underlying graph via traversals that are relative, using the current edge or vertex as their starting point. public interface Person extends VertexFrame { String getName (); List <? extends Person > getCoworkers (); } In this example Person represents a vertex in the graph with a property indicating their name, and they are associated with other vertex in the graph of the same type that represent their coworkers. When implementing a vertex as a concrete class you must instead inherit from AbstractVertexFrame . public class Person extends AbstractVertexFrame { public String getName () { return this . getProperty ( \"name\" ); } public List <? extends Person > getCoworkers () { return this . traverse ( v -> v . out ( \"coworker\" )). toList ( Person . class ); } } It is also possible to do the same with inheritance if you want a class and an interface defined. public class PersonImpl extends AbstractVertexFrame implements Person { @Override public String getName () { return this . getProperty ( \"name\" ); } @Override public List <? extends Person > getCoworkers () { return this . traverse ( v -> v . out ( \"coworker\" )). toList ( Person . class ); } } Note When implementing a Frame a class or abstract class must always extend from either AbstractEdgeFrame or AbstractVertexFrame . Typing \u00b6 There are two typing modes for ferma and each significantly effects how the user will determine the type of the objects pulled from the graph, these modes are called Typed Mode and Untyped Mode . When performing a traversal on a frame there are several methods provided which automatically encapsulate the underlying graph element or elements into a framed equivelant such as a VertexFrame or an EdgeFrame . This may be either a single frame, or a group of frames provided by an Iterator , Set , or List . In the earlier example we used a traversal to find all the coworkers and we used the toList() method to frame all the underlying vertex into the Person type. this . traverse ( v -> v . out ( \"coworker\" )). toList ( Person . class ); Traversals have several different methods availible that each frame and collect the underlying elements in different ways, those methods, members of the Traversable interface, are the following. < N > N next ( Class < N > kind ); < N > List <? extends N > next ( int amount , Class < N > kind ); < N > N nextOrDefault ( Class < N > kind , N defaultValue ); VertexFrame nextOrAdd (); < N > N nextOrAdd ( ClassInitializer < N > initializer ); < N > N nextOrAdd ( Class < N > kind ); < N > Iterator < N > frame ( Class < N > kind ); < N > List <? extends N > toList ( Class < N > kind ); < N > Set <? extends N > toSet ( Class < N > kind ); Note Each of these methods also have an equivelant method with the suffix Explicit , we will discuss those later as they only become important when we begin to discuss the differences between Typed Mode and Untyped Mode. Each of these methods has a slightly different behavior. For full details see the Ferma Javadocs for the Traversable class. However, in short, the next(Class) method returns any one of the matching elements and frames it as the specified type. It will throw an exception however if no vertex are found. The nextOrDefault varient avoids the exception by returning the default value when there are no matches, which can be 0 or null for example. Similarly nextOrAdd will add a new vertex to the underlying graph if the traversal yields no matches. Finally frame(Class) , toList(Class) , and toSet(Class) will return all elements that match the traversal as either a Iterator , List , or Set . The exact type returned from all the aforementioned calls will always be a Class of the type specified in the argument, or a subclass thereof. The exact type of the class instantiated will depend on which typing mode is being used. Untyped Mode \u00b6 In untyped mode there is never any Java type information encoded into the underlying graph. This means when you take an object off the graph there is no way for Ferma to know what Java type it is associated with and the user must select the type manually. Since a Frame just defines a set of behaviors and properties exposed for a particular graph element it can sometimes be useful to pick which Frame to use to represent an element based on how you need to interact with that element rather than a one to one mapping of element to a specific type. In such a scenario Untyped Mode might be the ideal choice. In this mode when framing elements from a traversal the type of the element is determined entierly from the parameters passed to the methods invoked on the Traversable class. The following is an example of how to frame a vertex as a Person class from above. // Open an untyped Framed Graph FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open ()); //create a vertex with no type information and a single name property VertexFrame vertex = fg . addFramedVertex ( VertexFrame . class ); vertex . setProperty ( \"name\" , \"Jeff\" ); //retrieve the vertex we just created but this time frame it as a Person Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). nextExplicit ( Person . class ); assert person . getName (). equals ( \"Jeff\" ); Note In untyped mode all the Traversal methods with the suffix of Explicit behave exactly the same as those methods without the suffix. Therefore when working in untyped mode it is suggested you only use explicit methods. This way if you ever decide to migrate over to typed mode it will not change the behavior of your existing code base and will make the migration process much easier. Typed Mode \u00b6 Typed mode takes things one step further and allows type information about a frame to be encoded as a property on vertex and edges in the underlying graph. This behavior is governed by the PolymorphicTypeResolver which encodes the type in a property name which defaults to the value of PolymorphicTypeResolver.TYPE_RESOLUTION_KEY but can be explicitly set to any string value of the user's choice. When a class is framed the Type Resolution Key is read and the original type is determined, this in turn effects the type used to instantiate the new Frame and may be a specific type which is a subclass of the type requested. For example say we have the following model. public class Person extends AbstractVertexFrame { public String getName () { return this . getProperty ( \"name\" ); } public List <? extends Person > getFriends () { return this . traverse ( v -> v . out ( \"friend\" )). toList ( Person . class ); } } public class Programmer extends Person { @Override public List <? extends Programmer > getFriends () { //Programmers don't have friends :( return Collections . emptyList (); } } In this case we can encode a Programmer vertex into the graph and even if we try to retrieve and frame that vertex as a VertexFrame or Person in the future the instantiated type will still be Programmer . This allows for a truly polymorphic Graph Data Model that leverages method overriding and class inheritance functiuonality in the model. For example the following is possible now in Typed Mode. // Open a Framed Graph in Typed Mode FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open (), true , false ); //create a vertex with type information specifying it as the Programmer type Programmer programmer = fg . addFramedVertex ( Programmer . class ); programmer . setName ( \"Jeff\" ); //retrieve the vertex we just created and check it is instantiated as a Programer Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). next ( Person . class ); assert person instanceof Programmer ; assert person . getFriends (). isEmpty (); The methods with the Explicit suffix are particularly meaningful for Typed Mode. In this mode they bypass the encoded typing completely and instantiate the frame as if in Untyped Mode. The following code snippet provides an example using the same model. // Open typed Framed Graph FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open (), true , false ); //create a vertex with type information specifying it as the Programmer type Programmer programmer = fg . addFramedVertex ( Programmer . class ); programmer . setName ( \"Jeff\" ); //retrieve the vertex we just created, since we are using an excplicit method the type won't be Programmer this time. Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). nextExplicit ( Person . class ); assert ! ( person instanceof Programmer ); The following are the list of explicit method types in the Traversable class. < N > N nextExplicit ( Class < N > kind ); < N > List <? extends N > nextExplicit ( int amount , Class < N > kind ); < N > N nextOrDefaultExplicit ( Class < N > kind , N defaultValue ); < N > N nextOrAddExplicit ( ClassInitializer < N > initializer ); < N > N nextOrAddExplicit ( Class < N > kind ); < N > Iterator <? extends N > frameExplicit ( Class < N > kind ); < N > List <? extends N > toListExplicit ( Class < N > kind ); < N > Set <? extends N > toSetExplicit ( Class < N > kind ); It is also possible to change the type encoded in the underlying graph after the element has already been created. The following example demonstrates this feature. FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open (), true , false ); //create a vertex with type information specifying it as the Programmer type Programmer programmer = fg . addFramedVertex ( Programmer . class ); programmer . setName ( \"Jeff\" ); //retrieve the vertex we just created and check it is instantiated as a Programer Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). next ( Person . class ); assert person instanceof Programmer ; //change the type resolution to person person . setTypeResolution ( Person . class ); //retrieve the vertex again to show the type changed person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). next ( Person . class ); assert ( ! ( person instanceof Programmer )); assert ( person instanceof Person );","title":"Object Mapping"},{"location":"object_mapping/#typing","text":"There are two typing modes for ferma and each significantly effects how the user will determine the type of the objects pulled from the graph, these modes are called Typed Mode and Untyped Mode . When performing a traversal on a frame there are several methods provided which automatically encapsulate the underlying graph element or elements into a framed equivelant such as a VertexFrame or an EdgeFrame . This may be either a single frame, or a group of frames provided by an Iterator , Set , or List . In the earlier example we used a traversal to find all the coworkers and we used the toList() method to frame all the underlying vertex into the Person type. this . traverse ( v -> v . out ( \"coworker\" )). toList ( Person . class ); Traversals have several different methods availible that each frame and collect the underlying elements in different ways, those methods, members of the Traversable interface, are the following. < N > N next ( Class < N > kind ); < N > List <? extends N > next ( int amount , Class < N > kind ); < N > N nextOrDefault ( Class < N > kind , N defaultValue ); VertexFrame nextOrAdd (); < N > N nextOrAdd ( ClassInitializer < N > initializer ); < N > N nextOrAdd ( Class < N > kind ); < N > Iterator < N > frame ( Class < N > kind ); < N > List <? extends N > toList ( Class < N > kind ); < N > Set <? extends N > toSet ( Class < N > kind ); Note Each of these methods also have an equivelant method with the suffix Explicit , we will discuss those later as they only become important when we begin to discuss the differences between Typed Mode and Untyped Mode. Each of these methods has a slightly different behavior. For full details see the Ferma Javadocs for the Traversable class. However, in short, the next(Class) method returns any one of the matching elements and frames it as the specified type. It will throw an exception however if no vertex are found. The nextOrDefault varient avoids the exception by returning the default value when there are no matches, which can be 0 or null for example. Similarly nextOrAdd will add a new vertex to the underlying graph if the traversal yields no matches. Finally frame(Class) , toList(Class) , and toSet(Class) will return all elements that match the traversal as either a Iterator , List , or Set . The exact type returned from all the aforementioned calls will always be a Class of the type specified in the argument, or a subclass thereof. The exact type of the class instantiated will depend on which typing mode is being used.","title":"Typing"},{"location":"object_mapping/#untyped-mode","text":"In untyped mode there is never any Java type information encoded into the underlying graph. This means when you take an object off the graph there is no way for Ferma to know what Java type it is associated with and the user must select the type manually. Since a Frame just defines a set of behaviors and properties exposed for a particular graph element it can sometimes be useful to pick which Frame to use to represent an element based on how you need to interact with that element rather than a one to one mapping of element to a specific type. In such a scenario Untyped Mode might be the ideal choice. In this mode when framing elements from a traversal the type of the element is determined entierly from the parameters passed to the methods invoked on the Traversable class. The following is an example of how to frame a vertex as a Person class from above. // Open an untyped Framed Graph FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open ()); //create a vertex with no type information and a single name property VertexFrame vertex = fg . addFramedVertex ( VertexFrame . class ); vertex . setProperty ( \"name\" , \"Jeff\" ); //retrieve the vertex we just created but this time frame it as a Person Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). nextExplicit ( Person . class ); assert person . getName (). equals ( \"Jeff\" ); Note In untyped mode all the Traversal methods with the suffix of Explicit behave exactly the same as those methods without the suffix. Therefore when working in untyped mode it is suggested you only use explicit methods. This way if you ever decide to migrate over to typed mode it will not change the behavior of your existing code base and will make the migration process much easier.","title":"Untyped Mode"},{"location":"object_mapping/#typed-mode","text":"Typed mode takes things one step further and allows type information about a frame to be encoded as a property on vertex and edges in the underlying graph. This behavior is governed by the PolymorphicTypeResolver which encodes the type in a property name which defaults to the value of PolymorphicTypeResolver.TYPE_RESOLUTION_KEY but can be explicitly set to any string value of the user's choice. When a class is framed the Type Resolution Key is read and the original type is determined, this in turn effects the type used to instantiate the new Frame and may be a specific type which is a subclass of the type requested. For example say we have the following model. public class Person extends AbstractVertexFrame { public String getName () { return this . getProperty ( \"name\" ); } public List <? extends Person > getFriends () { return this . traverse ( v -> v . out ( \"friend\" )). toList ( Person . class ); } } public class Programmer extends Person { @Override public List <? extends Programmer > getFriends () { //Programmers don't have friends :( return Collections . emptyList (); } } In this case we can encode a Programmer vertex into the graph and even if we try to retrieve and frame that vertex as a VertexFrame or Person in the future the instantiated type will still be Programmer . This allows for a truly polymorphic Graph Data Model that leverages method overriding and class inheritance functiuonality in the model. For example the following is possible now in Typed Mode. // Open a Framed Graph in Typed Mode FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open (), true , false ); //create a vertex with type information specifying it as the Programmer type Programmer programmer = fg . addFramedVertex ( Programmer . class ); programmer . setName ( \"Jeff\" ); //retrieve the vertex we just created and check it is instantiated as a Programer Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). next ( Person . class ); assert person instanceof Programmer ; assert person . getFriends (). isEmpty (); The methods with the Explicit suffix are particularly meaningful for Typed Mode. In this mode they bypass the encoded typing completely and instantiate the frame as if in Untyped Mode. The following code snippet provides an example using the same model. // Open typed Framed Graph FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open (), true , false ); //create a vertex with type information specifying it as the Programmer type Programmer programmer = fg . addFramedVertex ( Programmer . class ); programmer . setName ( \"Jeff\" ); //retrieve the vertex we just created, since we are using an excplicit method the type won't be Programmer this time. Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). nextExplicit ( Person . class ); assert ! ( person instanceof Programmer ); The following are the list of explicit method types in the Traversable class. < N > N nextExplicit ( Class < N > kind ); < N > List <? extends N > nextExplicit ( int amount , Class < N > kind ); < N > N nextOrDefaultExplicit ( Class < N > kind , N defaultValue ); < N > N nextOrAddExplicit ( ClassInitializer < N > initializer ); < N > N nextOrAddExplicit ( Class < N > kind ); < N > Iterator <? extends N > frameExplicit ( Class < N > kind ); < N > List <? extends N > toListExplicit ( Class < N > kind ); < N > Set <? extends N > toSetExplicit ( Class < N > kind ); It is also possible to change the type encoded in the underlying graph after the element has already been created. The following example demonstrates this feature. FramedGraph fg = new DelegatingFramedGraph ( TinkerGraph . open (), true , false ); //create a vertex with type information specifying it as the Programmer type Programmer programmer = fg . addFramedVertex ( Programmer . class ); programmer . setName ( \"Jeff\" ); //retrieve the vertex we just created and check it is instantiated as a Programer Person person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). next ( Person . class ); assert person instanceof Programmer ; //change the type resolution to person person . setTypeResolution ( Person . class ); //retrieve the vertex again to show the type changed person = fg . traverse ( g -> g . V (). property ( \"name\" , \"jeff\" )). next ( Person . class ); assert ( ! ( person instanceof Programmer )); assert ( person instanceof Person );","title":"Typed Mode"},{"location":"annotations/adjacency/","text":"Valid on frames: Vertex Allowed prefixes when operation is AUTO: add , get , remove , set Annotation arguments: label - The label assigned to the edge which connects the adjacent nodes. direction - The direction for the edge which creates the adjacency. It can be assigned any of the values from org.apache.tinkerpop.gremlin.structure.Direction . operation - The operation the method will perform. Must be one of the following: GET , ADD , SET , REMOVE , AUTO . Defaults to AUTO . example: @Adjacency ( \"foo\" ) //Method declared here ADD Operation \u00b6 Valid method signatures: ( ) , (VertexFrame) , (ClassInitializer) , (ClassInitializer, ClassInitializer) , (VertexFrame, ClassInitializer) Adds a node as an adjacency to the current node, and the returns the newly connected node. Signature: ( ) \u00b6 Valid return types: VertexFrame Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created VertexFrame is returned. Note Since the returned VertexFrame is always untyped the return type must be either VertexFrame or TVertex specifically. example: @Adjacency ( \"Foo\" ) VertexFrame addFoobar (); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) VertexFrame includeFoobar (); Signature: (VertexFrame) \u00b6 Valid return types: VertexFrame or void Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument to the method. The frame returned is the same as the frame given in the argument, it is only there for compatability with other add methods. This method can also have a void return type. examples: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( BarVertex existingVertex ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( E existingVertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( E existingVertex ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) void includeFoobar ( BarVertex existingVertex ); Signature: (ClassInitializer) \u00b6 Valid return types: VertexFrame Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type. example: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( ClassInitializer <? extends E > vertexInitializer ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( ClassInitializer <? extends E > vertexInitializer ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) BarVertex includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); Signature: (ClassInitializer, ClassInitializer) \u00b6 Valid return types: VertexFrame Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge will hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used to narrow the return type. example: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( ClassInitializer <? extends E > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( ClassInitializer <? extends E > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) BarVertex includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); Signature: (VertexFrame, ClassInitializer) \u00b6 Valid return types: VertexFrame or void Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. The VertexFrame specified in the first argument will simply be returned. A void return type is also valid. Java generics can, and should, be used to narrow the return type as well as to restrict the ClassInitializer . example: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( BarVertex vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( E vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( BarVertex vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) void includeFoobar ( BarVertex vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); GET Operation \u00b6 Valid method signatures: () , (Class) Get's one or more adjacent vertex from the graph. Signature: ( ) \u00b6 Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent edges. If the return type is a single Frame then only the first instance is returned. If the return type is an Iterator or List or Set then it will supply all matching vertex. When using an Iterator or List or Set it is encouraged, but not required, to use generics. The returned frames will always be instantiated as the type encoded in the graph if there is one. Note If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown. Therefore the return type specifed should always by the same type, or a superclass, of the expected return type. VertexFrame is always a safe return type for this method. example: @Adjacency ( \"Foo\" ) BarVertex getFoobar (); @Adjacency ( \"Foo\" ) < E extends BarVertex > E getFoobar (); @Adjacency ( \"Foo\" ) < E extends VertexFrame > E getFoobar (); @Adjacency ( \"Foo\" ) Iterator < BarVertex > getFoobar (); @Adjacency ( \"Foo\" ) < E extends BarVertex > Iterator < E > getFoobar (); @Adjacency ( \"Foo\" ) < E extends VertexFrame > Iterator < E > getFoobar (); @Adjacency ( \"Foo\" ) List < BarVertex > getFoobar (); @Adjacency ( \"Foo\" , direction = Direction . IN ) Set < BarVertex > getFoobar (); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . GET ) BarVertex obtainFoobar (); Signature: (Class) \u00b6 Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent vertex. If the return type is a single VertexFrame then only the first instance is returned. If the return type is an Iterator then it will iterate over all matching vertex. When using an Iterator it is encouraged to use generics. Note The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype, to that of the argument will be returned. example: @Adjacency ( \"Foo\" ) BarVertex getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) < E extends VertexFrame > E getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) Iterator < BarVertex > getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( \"Foo\" ) < E extends BarVertex > Iterator < E > getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) < E extends VertexFrame > Iterator < E > getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) List < BarVertex > getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( \"Foo\" , direction = Direction . IN ) Set < BarVertex > getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . GET ) BarVertex obtainFoobar ( Class <? extends BarVertex > filter ); REMOVE Operation \u00b6 Valid method signatures: ( ) , (VertexFrame) Removes any edges which cause an adjacency, leaving the vertex in place. Signature: ( ) \u00b6 Valid return types: void Removes all edges which create any adjacency between the current vertex and any other vertex using the specified label. example: @Adjacency ( \"Foo\" ) void removeFoobar (); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . REMOVE ) void deleteAllFoobar ( E vertex ); Signature: (VertexFrame) \u00b6 Valid return types: void Removes all edges which create an adjacency between the current vertex and the vertex specified in the methods argument and has the specified label. example: @Adjacency ( \"Foo\" ) void removeFoobar ( BarVertex vertex ); @Adjacency ( \"Foo\" ) < E extends BarVertex > void removeFoobar ( E vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > void removeFoobar ( E vertex ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . REMOVE ) void removeFoobar ( BarVertex vertex ); SET Operation \u00b6 Valid method signatures: (VertexFrame) , (Iterator) , (Iterable) Creates new edges connected to several vertex and at the same time removes any existing edges. If the any of the vertex being set are already an adjacency then the edge will still be removed and recreated. Warning The set operation methods are equivelant to removing all existing edges of the specified label and direction connected to the current vertex and then call add on all the vertex specified by the method's parameters. You will loose any existing properties set on all dropped edges as well. Signature: (VertexFrame) \u00b6 Valid return types: void The argument for this method must be a VertexFrame or a class or interface which inherits from that class. This method will drop all existing edges with the specified label and create a single new edge to the vertex specified. Of course if the direction is set to both then two new edges are created instead, one in each direction. Any newly created edges will not encode a type. Warning If the vertex specified in the method's argument already has an edge forming an adjacency with this vertex and has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with the same label. example: @Adjacency ( \"Foo\" ) void setFoobar ( BarVertex vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends BarVertex > void setFoobar ( E vertex ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . SET ) void assignFoobar ( BarVertex vertex ); Signature: (Iterator) \u00b6 Valid return types: void The argument for this method must be an Iterator which iterates over Vertex Frames. It is suggested you specify a Generic Type for the Iterator for usability. This method will drop all existing edges with the specified lable then iterate over all the vertex specified in the Iterator argument and create new edges to connect to them. The edges in the graph will not encode a type. Warning If any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex and has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with the same label. example: @Adjacency ( \"Foo\" ) void setFoobar ( Iterator < BarVertexr > vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends BarVertex > void setFoobar ( Iterator <? extends E > vertex ); @Adjacency ( \"Foo\" , operation = Adjacency . Operation . SET ) < E extends VertexFrame > void includeFoobar ( Iterator <? extends E > vertex ); Signature: (Iterable) \u00b6 Valid return types: void The argument for this method must be an Iterable or a subclass of Iterable which iterates over vertex Frames. It is suggested you specify a Generic Type for the Iterator for usability. Since all Java collections inherit from the Iterable interface any collection type can also be used as a parameter to this methods. This method will drop all existing edges with the specified lable then iterate over all the vertex specified in the Iterable argument and create new edges to connect to them. The edges in the graph will not encode a type. Warning If any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex and has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with the same label. example: @Adjacency ( \"Foo\" ) void setFoobar ( Iterable < BarVertex > vertex ); @Adjacency ( \"Foo\" ) void setFoobar ( Collection < BarVertex > vertex ); @Adjacency ( \"Foo\" ) void setFoobar ( List < BarVertex > vertex ); @Adjacency ( \"Foo\" ) void setFoobar ( Set < BarVertex > vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends BarVertex > void setFoobar ( Iterable <? extends E > vertex ); @Adjacency ( \"Foo\" , operation = Adjacency . Operation . SET ) < E extends VertexFrame > void includeFoobar ( Iterable <? extends E > vertex );","title":"@Adjacency"},{"location":"annotations/adjacency/#add-operation","text":"Valid method signatures: ( ) , (VertexFrame) , (ClassInitializer) , (ClassInitializer, ClassInitializer) , (VertexFrame, ClassInitializer) Adds a node as an adjacency to the current node, and the returns the newly connected node.","title":"ADD Operation"},{"location":"annotations/adjacency/#signature","text":"Valid return types: VertexFrame Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created VertexFrame is returned. Note Since the returned VertexFrame is always untyped the return type must be either VertexFrame or TVertex specifically. example: @Adjacency ( \"Foo\" ) VertexFrame addFoobar (); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) VertexFrame includeFoobar ();","title":"Signature: ( )"},{"location":"annotations/adjacency/#signature-vertexframe","text":"Valid return types: VertexFrame or void Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument to the method. The frame returned is the same as the frame given in the argument, it is only there for compatability with other add methods. This method can also have a void return type. examples: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( BarVertex existingVertex ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( E existingVertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( E existingVertex ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) void includeFoobar ( BarVertex existingVertex );","title":"Signature: (VertexFrame)"},{"location":"annotations/adjacency/#signature-classinitializer","text":"Valid return types: VertexFrame Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type. example: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( ClassInitializer <? extends E > vertexInitializer ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( ClassInitializer <? extends E > vertexInitializer ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) BarVertex includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer );","title":"Signature: (ClassInitializer)"},{"location":"annotations/adjacency/#signature-classinitializer-classinitializer","text":"Valid return types: VertexFrame Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge will hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used to narrow the return type. example: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( ClassInitializer <? extends E > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( ClassInitializer <? extends E > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) BarVertex includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer );","title":"Signature: (ClassInitializer, ClassInitializer)"},{"location":"annotations/adjacency/#signature-vertexframe-classinitializer","text":"Valid return types: VertexFrame or void Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. The VertexFrame specified in the first argument will simply be returned. A void return type is also valid. Java generics can, and should, be used to narrow the return type as well as to restrict the ClassInitializer . example: @Adjacency ( \"Foo\" ) BarVertex addFoobar ( BarVertex vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E addFoobar ( E vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > E addFoobar ( BarVertex vertex , ClassInitializer <? extends FooEdge > edgeInitializer ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) void includeFoobar ( BarVertex vertex , ClassInitializer <? extends FooEdge > edgeInitializer );","title":"Signature: (VertexFrame, ClassInitializer)"},{"location":"annotations/adjacency/#get-operation","text":"Valid method signatures: () , (Class) Get's one or more adjacent vertex from the graph.","title":"GET Operation"},{"location":"annotations/adjacency/#signature_1","text":"Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent edges. If the return type is a single Frame then only the first instance is returned. If the return type is an Iterator or List or Set then it will supply all matching vertex. When using an Iterator or List or Set it is encouraged, but not required, to use generics. The returned frames will always be instantiated as the type encoded in the graph if there is one. Note If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown. Therefore the return type specifed should always by the same type, or a superclass, of the expected return type. VertexFrame is always a safe return type for this method. example: @Adjacency ( \"Foo\" ) BarVertex getFoobar (); @Adjacency ( \"Foo\" ) < E extends BarVertex > E getFoobar (); @Adjacency ( \"Foo\" ) < E extends VertexFrame > E getFoobar (); @Adjacency ( \"Foo\" ) Iterator < BarVertex > getFoobar (); @Adjacency ( \"Foo\" ) < E extends BarVertex > Iterator < E > getFoobar (); @Adjacency ( \"Foo\" ) < E extends VertexFrame > Iterator < E > getFoobar (); @Adjacency ( \"Foo\" ) List < BarVertex > getFoobar (); @Adjacency ( \"Foo\" , direction = Direction . IN ) Set < BarVertex > getFoobar (); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . GET ) BarVertex obtainFoobar ();","title":"Signature: ( )"},{"location":"annotations/adjacency/#signature-class","text":"Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent vertex. If the return type is a single VertexFrame then only the first instance is returned. If the return type is an Iterator then it will iterate over all matching vertex. When using an Iterator it is encouraged to use generics. Note The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype, to that of the argument will be returned. example: @Adjacency ( \"Foo\" ) BarVertex getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( \"Foo\" ) < E extends BarVertex > E getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) < E extends VertexFrame > E getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) Iterator < BarVertex > getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( \"Foo\" ) < E extends BarVertex > Iterator < E > getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) < E extends VertexFrame > Iterator < E > getFoobar ( Class <? extends E > filter ); @Adjacency ( \"Foo\" ) List < BarVertex > getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( \"Foo\" , direction = Direction . IN ) Set < BarVertex > getFoobar ( Class <? extends BarVertex > filter ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . GET ) BarVertex obtainFoobar ( Class <? extends BarVertex > filter );","title":"Signature: (Class)"},{"location":"annotations/adjacency/#remove-operation","text":"Valid method signatures: ( ) , (VertexFrame) Removes any edges which cause an adjacency, leaving the vertex in place.","title":"REMOVE Operation"},{"location":"annotations/adjacency/#signature_2","text":"Valid return types: void Removes all edges which create any adjacency between the current vertex and any other vertex using the specified label. example: @Adjacency ( \"Foo\" ) void removeFoobar (); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . REMOVE ) void deleteAllFoobar ( E vertex );","title":"Signature: ( )"},{"location":"annotations/adjacency/#signature-vertexframe_1","text":"Valid return types: void Removes all edges which create an adjacency between the current vertex and the vertex specified in the methods argument and has the specified label. example: @Adjacency ( \"Foo\" ) void removeFoobar ( BarVertex vertex ); @Adjacency ( \"Foo\" ) < E extends BarVertex > void removeFoobar ( E vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends VertexFrame > void removeFoobar ( E vertex ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . REMOVE ) void removeFoobar ( BarVertex vertex );","title":"Signature: (VertexFrame)"},{"location":"annotations/adjacency/#set-operation","text":"Valid method signatures: (VertexFrame) , (Iterator) , (Iterable) Creates new edges connected to several vertex and at the same time removes any existing edges. If the any of the vertex being set are already an adjacency then the edge will still be removed and recreated. Warning The set operation methods are equivelant to removing all existing edges of the specified label and direction connected to the current vertex and then call add on all the vertex specified by the method's parameters. You will loose any existing properties set on all dropped edges as well.","title":"SET Operation"},{"location":"annotations/adjacency/#signature-vertexframe_2","text":"Valid return types: void The argument for this method must be a VertexFrame or a class or interface which inherits from that class. This method will drop all existing edges with the specified label and create a single new edge to the vertex specified. Of course if the direction is set to both then two new edges are created instead, one in each direction. Any newly created edges will not encode a type. Warning If the vertex specified in the method's argument already has an edge forming an adjacency with this vertex and has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with the same label. example: @Adjacency ( \"Foo\" ) void setFoobar ( BarVertex vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends BarVertex > void setFoobar ( E vertex ); @Adjacency ( value = \"Foo\" , operation = Adjacency . Operation . SET ) void assignFoobar ( BarVertex vertex );","title":"Signature: (VertexFrame)"},{"location":"annotations/adjacency/#signature-iterator","text":"Valid return types: void The argument for this method must be an Iterator which iterates over Vertex Frames. It is suggested you specify a Generic Type for the Iterator for usability. This method will drop all existing edges with the specified lable then iterate over all the vertex specified in the Iterator argument and create new edges to connect to them. The edges in the graph will not encode a type. Warning If any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex and has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with the same label. example: @Adjacency ( \"Foo\" ) void setFoobar ( Iterator < BarVertexr > vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends BarVertex > void setFoobar ( Iterator <? extends E > vertex ); @Adjacency ( \"Foo\" , operation = Adjacency . Operation . SET ) < E extends VertexFrame > void includeFoobar ( Iterator <? extends E > vertex );","title":"Signature: (Iterator)"},{"location":"annotations/adjacency/#signature-iterable","text":"Valid return types: void The argument for this method must be an Iterable or a subclass of Iterable which iterates over vertex Frames. It is suggested you specify a Generic Type for the Iterator for usability. Since all Java collections inherit from the Iterable interface any collection type can also be used as a parameter to this methods. This method will drop all existing edges with the specified lable then iterate over all the vertex specified in the Iterable argument and create new edges to connect to them. The edges in the graph will not encode a type. Warning If any of the vertex specified by this method's argument already has an edge forming an adjacency with this vertex and has matching direction and label attributes then that edge will be removed and recreated as a blank untyped edge with the same label. example: @Adjacency ( \"Foo\" ) void setFoobar ( Iterable < BarVertex > vertex ); @Adjacency ( \"Foo\" ) void setFoobar ( Collection < BarVertex > vertex ); @Adjacency ( \"Foo\" ) void setFoobar ( List < BarVertex > vertex ); @Adjacency ( \"Foo\" ) void setFoobar ( Set < BarVertex > vertex ); @Adjacency ( \"Foo\" , direction = Direction . IN ) < E extends BarVertex > void setFoobar ( Iterable <? extends E > vertex ); @Adjacency ( \"Foo\" , operation = Adjacency . Operation . SET ) < E extends VertexFrame > void includeFoobar ( Iterable <? extends E > vertex );","title":"Signature: (Iterable)"},{"location":"annotations/graphelement/","text":"Valid on frames: Edge and vertex The @GraphElement annotation takes no parameters and is placed before your class decleration on an EdgeFrame or VertexFrame . This annotation is mostly leveraged right now when scanning classes in a package to identify frames. example: @GraphElement public interface FooVertex extends VertexFrame { //Methods goes here }","title":"@GraphElement"},{"location":"annotations/incidence/","text":"Valid on frames: Vertex Allowed prefixes when operation is AUTO: add , get , remove Annotation arguments: label - The label assigned to the edge which connects the adjacent nodes. direction - The direction for the edge which creates the adjacency. It can be assigned any of the values from org.apache.tinkerpop.gremlin.structure.Direction . operation - The operation the method will perform. Must be one of the following: GET , ADD , SET , REMOVE , AUTO . Defaults to AUTO . example: @Incidence ( \"foo\" ) //Method declared here ADD Operation \u00b6 Valid method signatures: ( ) , (VertexFrame) , (ClassInitializer) , (VertexFrame, ClassInitializer) , (ClassInitializer, ClassInitializer) Adds an edge to edge to a node and returns the new EdgeFrame . Signature: ( ) \u00b6 Valid return types: EdgeFrame Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created TEdge is returned. Note Since the returned VertexFrame is always untyped the return type must be either VertexFrame or TVertex specifically. @Incidence ( \"Foo\" ) EdgeFrame addFoobar (); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) TEdge addFoobar (); Signature: (VertexFrame) \u00b6 Valid return types: EdgeFrame Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument to the method. The frame returned is the newly created TEdge . examples: @Incidence ( \"Foo\" ) FooEdge addFoobar ( BarVertex existingVertex ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( BarVertex existingVertex ); @Incidence ( \"Foo\" ) EdgeFrame addFoobar ( BarVertex existingVertex ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > E addFoobar ( BarVertex existingVertex ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) FooEdge includeFoobar ( BarVertex existingVertex ); Signature: (ClassInitializer) \u00b6 Valid return types: EdgeFrame Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be the newly created TEdge . example: @Incidence ( \"Foo\" ) FooEdge addFoobar ( ClassInitializer <? extends FooEdge > vertexInitializer ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends FooEdge > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) TEdge includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); Signature: (VertexFrame, ClassInitializer) \u00b6 Valid return types: EdgeFrame Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be the newly created EdgeFrame . example: @Incidence ( \"Foo\" ) FooEdge addFoobar ( BarVertex bar , ClassInitializer <? extends FooEdge > edgeInitializer ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( BarVertex bar , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > E addFoobar ( VertexFrame vertex , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) FooEdge includeFoobar ( BarVertex bar , ClassInitializer <? extends FooEdge > edgeInitializer ); Signature: (ClassInitializer, ClassInitializer) \u00b6 Valid return types: EdgeFrame Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge will hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be the newly created EdgeFrame . example: @Incidence ( \"Foo\" ) FooEdge addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) FooEdge includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); GET Operation \u00b6 Valid method signatures: () , (Class) Get's one or more adjacent edgesd from the graph. Signature: ( ) \u00b6 Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent vertex. If the return type is a single Frame then only the first instance is returned. If the return type is an Iterator or List or Set then it will supply all matching edges. When using an Iterator or List or Set it is encouraged, but not required, to use generics. The returned frames will always be instantiated as the type encoded in the graph if there is one. Note If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown. Therefore the return type specifed should always by the same type, or a superclass, of the expected return type. VertexFrame is always a safe return type for this method. example: @Incidence ( \"Foo\" ) FooEdge getFoobar (); @Incidence ( \"Foo\" ) < E extends FooEdge > E getFoobar (); @Incidence ( \"Foo\" ) < E extends EdgeFrame > E getFoobar (); @Incidence ( \"Foo\" ) Iterator < FooEdge > getFoobar (); @Incidence ( \"Foo\" ) < E extends FooEdge > Iterator < E > getFoobar (); @Incidence ( \"Foo\" ) < E extends EdgeFrame > Iterator < E > getFoobar (); @Incidence ( \"Foo\" ) List < FooEdge > getFoobar (); @Incidence ( \"Foo\" , direction = Direction . IN ) Set < FooEdge > getFoobar (); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . GET ) FooEdge obtainFoobar (); Signature: (Class) \u00b6 Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent edges. If the return type is a single EdgeFrame then only the first instance is returned. If the return type is an Iterator then it will iterate over all matching vertex. When using an Iterator it is encouraged to use generics. Note The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype, to that of the argument will be returned. example: @Incidence ( \"Foo\" ) FooEdge getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( \"Foo\" ) < E extends FooEdge > E getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) < E extends FooEdge > E getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) Iterator < FooEdge > getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( \"Foo\" ) < E extends FooEdge > Iterator < E > getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) < E extends EdgeFrame > Iterator < E > getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) List < FooEdge > getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( \"Foo\" , direction = Direction . IN ) Set < FooEdge > getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . GET ) FooEdge obtainFoobar ( Class <? extends FooEdge > filter ); REMOVE Operation \u00b6 Valid method signatures: (EdgeFrame) Removes an edges which cause an adjacency, leaving the vertex in place. Signature: (EdgeFrame) \u00b6 Valid return types: void Removes the edge specified in the argument. This is entirely equivelant to just calling the remove() method on the EdgeFrame example: @Incidence ( \"Foo\" ) void removeFoobar ( FooEdge edge ); @Incidence ( \"Foo\" ) < E extends FooEdge > void removeFoobar ( E edge ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > void removeFoobar ( E edge ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . REMOVE ) void removeFoobar ( FooEdge edge );","title":"@Incidence"},{"location":"annotations/incidence/#add-operation","text":"Valid method signatures: ( ) , (VertexFrame) , (ClassInitializer) , (VertexFrame, ClassInitializer) , (ClassInitializer, ClassInitializer) Adds an edge to edge to a node and returns the new EdgeFrame .","title":"ADD Operation"},{"location":"annotations/incidence/#signature","text":"Valid return types: EdgeFrame Creates a new vertex without any type information as well as an untyped edge to connect to it. The newly created TEdge is returned. Note Since the returned VertexFrame is always untyped the return type must be either VertexFrame or TVertex specifically. @Incidence ( \"Foo\" ) EdgeFrame addFoobar (); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) TEdge addFoobar ();","title":"Signature: ( )"},{"location":"annotations/incidence/#signature-vertexframe","text":"Valid return types: EdgeFrame Creates a new edge without any type information and connects it between this vertex the vertex specified as an argument to the method. The frame returned is the newly created TEdge . examples: @Incidence ( \"Foo\" ) FooEdge addFoobar ( BarVertex existingVertex ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( BarVertex existingVertex ); @Incidence ( \"Foo\" ) EdgeFrame addFoobar ( BarVertex existingVertex ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > E addFoobar ( BarVertex existingVertex ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) FooEdge includeFoobar ( BarVertex existingVertex );","title":"Signature: (VertexFrame)"},{"location":"annotations/incidence/#signature-classinitializer","text":"Valid return types: EdgeFrame Creates a new edge without any type information and connects it between this vertex and a newly created vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be the newly created TEdge . example: @Incidence ( \"Foo\" ) FooEdge addFoobar ( ClassInitializer <? extends FooEdge > vertexInitializer ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends FooEdge > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) TEdge includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer );","title":"Signature: (ClassInitializer)"},{"location":"annotations/incidence/#signature-vertexframe-classinitializer","text":"Valid return types: EdgeFrame Creates a new edge and connects this to an existing vertex. The newly created edge will have a type, as well as be initiated, according to the details specified in the ClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be the newly created EdgeFrame . example: @Incidence ( \"Foo\" ) FooEdge addFoobar ( BarVertex bar , ClassInitializer <? extends FooEdge > edgeInitializer ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( BarVertex bar , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > E addFoobar ( VertexFrame vertex , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) FooEdge includeFoobar ( BarVertex bar , ClassInitializer <? extends FooEdge > edgeInitializer );","title":"Signature: (VertexFrame, ClassInitializer)"},{"location":"annotations/incidence/#signature-classinitializer-classinitializer","text":"Valid return types: EdgeFrame Creates a new edge and connects this to a new vertex. The newly created vertex will have a type, as well as be initiated, according to the details specified in the first ClassInitializer argument. Similarly the newly created edge will hava a type, and be initiated, using the second ClassInitializer argument. Java generics can, and should, be used to narrow the return type. The returned object will be the newly created EdgeFrame . example: @Incidence ( \"Foo\" ) FooEdge addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer ); @Incidence ( \"Foo\" ) < E extends FooEdge > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > E addFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends E > edgeInitializer ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . ADD ) FooEdge includeFoobar ( ClassInitializer <? extends BarVertex > vertexInitializer , ClassInitializer <? extends FooEdge > edgeInitializer );","title":"Signature: (ClassInitializer, ClassInitializer)"},{"location":"annotations/incidence/#get-operation","text":"Valid method signatures: () , (Class) Get's one or more adjacent edgesd from the graph.","title":"GET Operation"},{"location":"annotations/incidence/#signature_1","text":"Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent vertex. If the return type is a single Frame then only the first instance is returned. If the return type is an Iterator or List or Set then it will supply all matching edges. When using an Iterator or List or Set it is encouraged, but not required, to use generics. The returned frames will always be instantiated as the type encoded in the graph if there is one. Note If a type is encoded in the in the graph is a superclass of the returned element then an exception will be thrown. Therefore the return type specifed should always by the same type, or a superclass, of the expected return type. VertexFrame is always a safe return type for this method. example: @Incidence ( \"Foo\" ) FooEdge getFoobar (); @Incidence ( \"Foo\" ) < E extends FooEdge > E getFoobar (); @Incidence ( \"Foo\" ) < E extends EdgeFrame > E getFoobar (); @Incidence ( \"Foo\" ) Iterator < FooEdge > getFoobar (); @Incidence ( \"Foo\" ) < E extends FooEdge > Iterator < E > getFoobar (); @Incidence ( \"Foo\" ) < E extends EdgeFrame > Iterator < E > getFoobar (); @Incidence ( \"Foo\" ) List < FooEdge > getFoobar (); @Incidence ( \"Foo\" , direction = Direction . IN ) Set < FooEdge > getFoobar (); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . GET ) FooEdge obtainFoobar ();","title":"Signature: ( )"},{"location":"annotations/incidence/#signature-class","text":"Valid return types: VertexFrame or Iterator or List or Set Retrieves one or more of the adjacent edges. If the return type is a single EdgeFrame then only the first instance is returned. If the return type is an Iterator then it will iterate over all matching vertex. When using an Iterator it is encouraged to use generics. Note The Class argument of the method specifes a filter such that only vertex which are of a matching type, or a subtype, to that of the argument will be returned. example: @Incidence ( \"Foo\" ) FooEdge getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( \"Foo\" ) < E extends FooEdge > E getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) < E extends FooEdge > E getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) Iterator < FooEdge > getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( \"Foo\" ) < E extends FooEdge > Iterator < E > getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) < E extends EdgeFrame > Iterator < E > getFoobar ( Class <? extends E > filter ); @Incidence ( \"Foo\" ) List < FooEdge > getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( \"Foo\" , direction = Direction . IN ) Set < FooEdge > getFoobar ( Class <? extends FooEdge > filter ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . GET ) FooEdge obtainFoobar ( Class <? extends FooEdge > filter );","title":"Signature: (Class)"},{"location":"annotations/incidence/#remove-operation","text":"Valid method signatures: (EdgeFrame) Removes an edges which cause an adjacency, leaving the vertex in place.","title":"REMOVE Operation"},{"location":"annotations/incidence/#signature-edgeframe","text":"Valid return types: void Removes the edge specified in the argument. This is entirely equivelant to just calling the remove() method on the EdgeFrame example: @Incidence ( \"Foo\" ) void removeFoobar ( FooEdge edge ); @Incidence ( \"Foo\" ) < E extends FooEdge > void removeFoobar ( E edge ); @Incidence ( \"Foo\" , direction = Direction . IN ) < E extends EdgeFrame > void removeFoobar ( E edge ); @Incidence ( value = \"Foo\" , operation = Adjacency . Operation . REMOVE ) void removeFoobar ( FooEdge edge );","title":"Signature: (EdgeFrame)"},{"location":"annotations/invertex/","text":"Valid on frames: Edge Allowed prefixes when operation is AUTO: get The @InVertex takes no parameters and is used only on get methods that themself take no parameters. It specifies the VertexFrame at the head of an edge. example: @InVertex //Method declared here GET Operation \u00b6 Valid method signatures: ( ) Signature: ( ) \u00b6 Valid return types: VertexFrame . Get the head vertex of the edge. example: @InVertex BarVertex getFoobar ();","title":"@InVertex"},{"location":"annotations/invertex/#get-operation","text":"Valid method signatures: ( )","title":"GET Operation"},{"location":"annotations/invertex/#signature","text":"Valid return types: VertexFrame . Get the head vertex of the edge. example: @InVertex BarVertex getFoobar ();","title":"Signature: ( )"},{"location":"annotations/outvertex/","text":"Valid on frames: Edge Allowed prefixes when operation is AUTO: get The @OutVertex takes no parameters and is used only on get methods that themself take no parameters. It specifies the VertexFrame at the tail of an edge. example: @OutVertex //Method declared here GET Operation \u00b6 Valid method signatures: ( ) Signature: ( ) \u00b6 Valid return types: VertexFrame . Get the tail vertex of the edge. example: @OutVertex BarVertex getFoobar ();","title":"@OutVertex"},{"location":"annotations/outvertex/#get-operation","text":"Valid method signatures: ( )","title":"GET Operation"},{"location":"annotations/outvertex/#signature","text":"Valid return types: VertexFrame . Get the tail vertex of the edge. example: @OutVertex BarVertex getFoobar ();","title":"Signature: ( )"},{"location":"annotations/overview/","text":"The Ferma schema is defined by a collection of interfaces and classes written by the user. Each method will interact with the underlying graph to either modify the graph in some way, or to retrieve an element or property from the graph. There are two techniques for defining how these methods behave. Either you can explicitly implement the method, or you can leave the method as abstract and annotate the method in order to allow Ferma to implement the method for you. Here we will define the annotations available to you and how they work, along with a few examples. The behavior of an annotated method is dictated not only by the annotation applied to it but also the method's signature. Therefore an annotated method will behave differently if it's return type, arguments, or even if the method name were to change. It is important to note that when a method is explicitly defined (doesnt use an annotation) then the method signature can be anything. Method names that are annotated must have one of the following prefixes: add, get, remove, set, is. Exactly which prefixes are allowed varies from one annotation to the next so see the annotation's detailed documentation to make that determination. It is also possible to override this behavior by setting the operation argument available on most annotations which defaults to AUTO .","title":"Overview"},{"location":"annotations/property/","text":"Valid on frames: Edge and Vertex Allowed prefixes when operation is AUTO: get , is , can , set , remove Annotation arguments: value - The name of the property operation - The operation the method will perform. Must be one of the following: GET , SET , REMOVE , AUTO . Defaults to AUTO . The following would bind the method it is used on to the property named foo : @Property ( \"foo\" ) //Method declared here GET Operation \u00b6 Valid method signatures: ( ) Signature: ( ) \u00b6 Valid return types: Object or any primitive. Get the property value of an element. Used when property is not a boolean value. example: @Property ( \"Foo\" ) Bar getFoobar (); @Property ( \"Foo\" ) < E extends Bar > E getFoobar (); @Property ( \"Foo\" ) < E > E getFoobar (); @Property ( value = \"Foo\" , operation = Property . Operation . GET ) Bar obtainFoobar (); GET Operation (is prefix) \u00b6 Valid method signatures: ( ) Signature: ( ) \u00b6 Valid return types: boolean Get the property value of an element. Used when property is a boolean value. example: @Property ( \"Foobared\" ) boolean isFoobared (); @Property ( value = \"Foo\" , operation = Property . Operation . GET ) boolean obtainFoobared (); SET Operation \u00b6 Valid method signatures: (Object) Signature: (Object) \u00b6 Valid return types: void Set the property value of an element. The argument can be any class accepted by the underlying graph. example: @Property ( \"Foo\" ) void setFoobar ( Bar foobar ); @Property ( \"Foo\" ) < E extends Bar > void setFoobar ( E foobar ); @Property ( \"Foo\" ) < E extends VectorFrame > void setFoobar ( E foobar ); @Property ( \"Foo\" ) void setFoobar ( Bar foobar ); @Property ( value = \"Foo\" , operation = Property . Operation . SET ) void applyFoobar ( Bar foobar ); REMOVE Operation \u00b6 Valid method signatures: ( ) Signature: ( ) \u00b6 Valid return types: void Remove the property of an element. example: @Property ( \"Foo\" ) void removeFoobar (); @Property ( value = \"Foo\" , operation = Property . Operation . REMOVE ) void removeFoobar ();","title":"@Property"},{"location":"annotations/property/#get-operation","text":"Valid method signatures: ( )","title":"GET Operation"},{"location":"annotations/property/#signature","text":"Valid return types: Object or any primitive. Get the property value of an element. Used when property is not a boolean value. example: @Property ( \"Foo\" ) Bar getFoobar (); @Property ( \"Foo\" ) < E extends Bar > E getFoobar (); @Property ( \"Foo\" ) < E > E getFoobar (); @Property ( value = \"Foo\" , operation = Property . Operation . GET ) Bar obtainFoobar ();","title":"Signature: ( )"},{"location":"annotations/property/#get-operation-is-prefix","text":"Valid method signatures: ( )","title":"GET Operation (is prefix)"},{"location":"annotations/property/#signature_1","text":"Valid return types: boolean Get the property value of an element. Used when property is a boolean value. example: @Property ( \"Foobared\" ) boolean isFoobared (); @Property ( value = \"Foo\" , operation = Property . Operation . GET ) boolean obtainFoobared ();","title":"Signature: ( )"},{"location":"annotations/property/#set-operation","text":"Valid method signatures: (Object)","title":"SET Operation"},{"location":"annotations/property/#signature-object","text":"Valid return types: void Set the property value of an element. The argument can be any class accepted by the underlying graph. example: @Property ( \"Foo\" ) void setFoobar ( Bar foobar ); @Property ( \"Foo\" ) < E extends Bar > void setFoobar ( E foobar ); @Property ( \"Foo\" ) < E extends VectorFrame > void setFoobar ( E foobar ); @Property ( \"Foo\" ) void setFoobar ( Bar foobar ); @Property ( value = \"Foo\" , operation = Property . Operation . SET ) void applyFoobar ( Bar foobar );","title":"Signature: (Object)"},{"location":"annotations/property/#remove-operation","text":"Valid method signatures: ( )","title":"REMOVE Operation"},{"location":"annotations/property/#signature_2","text":"Valid return types: void Remove the property of an element. example: @Property ( \"Foo\" ) void removeFoobar (); @Property ( value = \"Foo\" , operation = Property . Operation . REMOVE ) void removeFoobar ();","title":"Signature: ( )"}]}